---
title: Terra Incognita
description: In this post I discuss maintainability of systems built around the microservices architecture and try to emphasize the importance of investing into gaining a proper understanding of the problem space.
date: 2024-06-21
tags:
  - Domain Driven Design
  - Microservices
---
In this post I discuss maintainability of systems built around the microservices architecture and try to emphasize the importance of investing into gaining a proper understanding of the problem space. The intended audience of this post are junior/mid level engineers that are new to microservices.

DISCLAIMER: The topic grew a bit larger than anticipated and the post has become quite lengthy! I'm still iterating on it but I've decided to post it in its current state.

## Introduction

There are, at all times, two models at play. There's a model of the problem space, which is a model of the business problem you're trying to solve and a model of the solution space which is your current code base. The model of the problem space may not be explicitly defined. It is often implicit and different people may have a different understanding of it. When the code is written this understanding of the problem space is used by the developers to model the code. It is often quite complicated and driven by the business so there is a high risk that the developers do not have a proper understanding, i.e. they end up implementing something else than what the business expected. A design approach called Domain Driven Design (DDD) has been invented to tackle this common issue by giving the developers a set of tools and design principles to help develop and maintain an explicit model of the domain (the problem space) which is aligned with the understanding of the problem space by the stakeholders and product owners. For example, developers might invite relevant subject matter experts to event storming sessions where they in collaboration come to a common understanding of the business processes and capabilities that define the domain they need to model. They'll develop artifacts, e.g. notes, descriptions, diagrams, wireframes etc. that describe the domain model, i.e. makes it explicit. DDD also contains many best practices that aims at aligning the solution space (the code) as much as possible to the problem space, e.g. by introducing a common "ubiquitous" language which is shared between people from the business and developers and that is used throughout the code base.

Throughout this blog post I will be using the term `bounded context`. The term comes from DDD and defines the boundary inside of which the "ubiquitous" language is well defined, i.e. where terms from the language has a single definition. Outside of it a term from the language may have a different meaning. In a microservice architecture the ownership of the solution is usually separated into multiple independent teams, as having the ability to do so is usually one of the primary reasons for choosing a microservice architecture. As each team is independent it follows that teams will not be sharing bounded contexts as that would require the teams to agree on every term used in their codes bases. On the other hand, it is possible for a single team to have multiple bounded contexts, e.g. they could be owning two services that both refer to the term `Product` but with different meanings. In this text, when the term `bounded context` is used you can also think "team" as a bounded context originates from a single team.

I often encounter the attitude that DDD is not worth the effort and in my opinion those developers are underestimating the impact it can have. When developing a distributed backend, I believe that DDD is a vital tool for decomposing the backend into smaller decoupled and autonomous components (e.g. microservices) and ensure clear and stable responsibility boundaries. In my opinion, building a microservice backend without an up front and continuous effort into understanding the problem space, e.g. by employing DDD, is a blatant mistake. A mistake that I see happening too often. Obviously the real world does not allow for idealism. Time to market and budgets demands short term focus rather than long term planning but it is the responsibility of the software developer or architect to make good and conscious decisions and I believe that even small efforts can have a compounding effect that will help scalability and maintainability on the mid to long term. Conversely, neglecting it will have adverse effects, on which I will give examples in the anti-patterns section.

DDD is a very large topic. This post will not be going into details about DDD, and although some familiarity with DDD concepts is a good prerequisite, the text can be read without prior knowledge, but the reader is encouraged to read up on DDD later. The post will not discuss all benefits and consequences of applying DDD, rather it will focus on a single aspect only, the maintainability/adaptability of the software.

My intention with this blog post is to increase the awareness of the importance of investing into understanding the problem space. In my opinion it will increase productivity, profitability and contribute to a happier developer life.

## Solution maintainability

The domain model (whether explicit or implicit) is not static. Like the business, it will evolve over time. New or changing requirements will continuously alter the domain model and as it changes the developers will need to evolve the code base to fit the new requirements. The concepts making up the domain model, like actors, entities, processes etc. are all related to each other, some more than others. When following a DDD approach, once all business processes has been sketched out in an event storming session it should stand out how the concepts are coupled to each other. The degree of coupling of all those relationships should be respected in the solution space. If something is closely related in the problem space that should also be the case in the code you write and if they're independent they should not be coupled in the code. This is in fact what is being expressed by Conway's law which you may already be familiar with:

{% quote 'Conway\'s law', 'Melvin E. Conway', 'How Do Committees Invent?' %}

Organizations which design systems (in the broad sense used here) are constrained to produce designs which are copies of the communication structures of these organizations.

{% endquote %}

If there's a misalignment between the problem space and the solution space, i.e. your code and the domain model are structured differently, simple changes in the problem space can turn out to be much harder to carry out in the solution space than they should be. To make this point let's turn to some of the quality metrics of software design that you're most likely already familiar with.

You're probably already familiar with the term **single responsibility** as it's often mentioned as an important quality attribute of software solutions. However, there can be different interpretations of what this concept means, so in order to avoid any confusion let's do a short recap here and establish what the author means when referring to those concepts.

The **single responsibility principle** states that a component (a class, module, microservice etc.) should have one and only one responsibility. What is meant by this? When does a component have multiple responsibilities?

Robert C. Martin has [expressed the principle](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html) as **a class should have only one reason to change**. Another way to express this is to say that in order to comply with the single responsibility principle code that changes for the same reason should be close together (coupled) where as code that changes for different reasons should not.

{% simplequote 'Robert C. Martin', 'The Clean Code Blog' %}

If you think about this youâ€™ll realize that this is just another way to define cohesion and coupling. We want to increase the cohesion between things that change for the same reasons, and we want to decrease the coupling between those things that change for different reasons.

{% endsimplequote %}

So what is a "reason to change" the code?

The reason to change the code comes from the stakeholders that operate in the problem space. They want new or improved features. The stakeholders are coming from the business and are organised using the business org chart. E.g. at Amazon there could be a stakeholder Aaron from the "product" department and another stakeholder Bridget from the "checkout" department. Aaron is concerned with how products are organised and presented on the Amazon site, Bridget is concerned with the user experience after a purchase decision has been made, e.g. what does the email receipt after the purchase look like? So if Aaron asked you to make a change to how product information is presented and you accidentally also changed how it was shown on the email receipt because the component you altered was being used in both places (i.e. it was responsible for delivering product information to both) then your component does not have a single responsibility. The product page and the email receipt are independent concepts in the problem space because the business has been organised in such a way that they are the responsibility of different departments that each have their own stakeholders. For that reason they will probably change independently and for different reasons. If Aaron wants the product information to look differently there is no reason to expect that Bridget will want the same change or even be aware that Aaron has requested the change.

So in this case the component was responsible for business logic that is coupled to multiple independent concepts in the problem space. The concepts are decoupled in the problem space but they were coupled in the solution space.

{% simplequote 'Robert C. Martin', 'The Clean Code Blog' %}

However, as you think about this principle, remember that the reasons for change are people. It is people who request changes. And you donâ€™t want to confuse those people, or yourself, by mixing together the code that many different people care about for different reasons.

{% endsimplequote %}

Having this misalignment of the problem space and solution space means that changing your solution will be hard. As the problem space evolves, changes to different parts of the problem space (which are independent and decoupled) will be difficult because of the entangled mess. A change which is simple to express in the problem space will be very hard to do in the solution space because the component responsible for the concept is coupled to other concepts from the problem space.

You can experience the inverse problem as well. Your component shares its responsibilities with other components. Those other components might even be owned by other teams. So when Aaron wants his change you'll need to make changes in multiple places in order for the change to be implemented. If multiple teams are owning the components this means coordination, meetings, project management etc. which could otherwise have been avoided. This is what is referred to as low cohesion in any `introduction to programming` text book, and it is an undesirable characteristic.

So this is really all about cohesion and coupling. You want high cohesion, behaviour that is related should be close together, and inversely behaviour/features that are unrelated should not be close together in the code, that is, have low coupling.

The crucial point here is that you cannot comply with the single responsibility principle (or more generally keeping cohesion and coupling in the code just right) unless you have a proper understanding of the problem space because the changes to the code (solution space) are driven by changes in the problem space. In other words things that change for the same reason do so because they're related in the problem space, and things that change for different reasons (and should therefore not be coupled in the code) do so because they're independent concepts in the problem space. So if you don't have a proper understanding of how concepts are related in the problem space how could you possibly make good decisions on how to structure your code in such a way that you don't break the single responsibility principle?

## Responsibility boundaries

When a system based on a microservice architecture is implemented without a proper understanding of the problem space it will result in accidental complexity, unintentional coupling and a tightly coupled architecture in general. This has many negative consequences but, as mentioned, in this post we will focus on maintainability. When the misalignment is allowed to exist you'll often be able to notice the consequences by observing the responsibility boundaries that exist between the bounded contexts in your backend. Some bounded contexts will have multiple responsibilities, some bounded contexts will share responsibilities with each other, and some boundaries will simply be unclear.

As mentioned earlier, in this post, we'll be focusing on challenges that arise when building systems using a microservice architecture. From the perspective of the single responsibility principle a microservice is just like any other component (e.g. classes or modules). However, microservice boundaries are a lot more rigid because they involve network and often team boundaries. This means that the single responsibility principle becomes even more important, because once you break it, it is much harder to refactor and correct the issue.

*In the rest of the post I will be assuming that teams are organised as stream-aligned/vertical teams. I.e. teams that has the power to take full stack domain ownership. If teams are instead organised in layers, e.g. a database team, a service team and a front-end team, it changes the discussion.*

There are three common cases of bad responsibility boundaries that you'll encounter, let's go through them here.

### Violation of the single responsibility principle

**A single component has the responsibility of multiple independent business capabilities or processes from the problem space.**

Because the implementation of the business capabilities are entangled in the code it will be difficult to evolve them independently. This can happen on many levels, it could be an aggregate inside a service taking up too much responsibility, it could be a service or a bounded context.

### Shared responsiblity

**The implementation of a single responsibility from the problem space is scattered between two or more independent components in the solution space.**

In a microservice architecture the components could be two bounded contexts owned by separate teams.

From the perspective of the owners this means that implementing a change request is hard because it requires the coordination of multiple teams. They must align roadmaps and all teams will depend on each other while implementing and testing the new changes.

From the perspective of dependent teams that must implement business rules or processes that are based on entities or events coming from the domain it will be difficult to implement and maintain their solutions. Since domain events are coming from multiple bounded contexts how do they know that they have consumed all relevant events, and how can they be sure which events are relevant, the publishers might use different names for the same thing, or the same name for different things. Likewise how could they ensure that their solution will continue to subscribe to all events in the future, if ownership is already scattered, what's to stop yet another team from publishing new events belonging to the domain in the future? Similar problems arise when relying on scattered APIs.

### Inconsistent responsibility boundaries

**There are clear responsibility boundaries but they are drawn inconsistently across another orthogonal dimension.**

A Business capability is owned by a single team A, except for the cases where the users logged in are coming from country C, in those cases the business capability is owned by team B.

This will obviously make it harder to evolve the business capability because both team A and team B will need to be involved, at least if feature parity is a concern. It will also likely cause a lot of duplicated effort.

## Anti-patterns

In the next section we will look at common cases of bad decision making that reduce the maintainability of the system, but first, let's examine a set of common anti-patterns related to maintainability that are frequently observed in systems where the understanding of the problem space has been lacking. The list is not exhaustive.

### Anti-pattern 1: Bad fit

As the problem space evolves it is natural to consider reusing or extending existing components to support the new business processes/capabilities. It might be possible to support the new requirements using an existing component by making minor extensions, e.g. by making functionality more generic and configurable or adding branching logic. If one does not consider whether the new business capability/process is part of the same domain as the existing functionality this can lead to [Violation of the single responsibility principle](#violation-of-the-single-responsibility-principle) and [misaligned abstraction](#misaligned-abstraction).

{% note 'Real world example' %}

A team was responsible for a core domain that was depended on by many other domains. Those other domains represented the products delivered to the users of the system. The company was using stream aligned teams (i.e. teams with vertical/fullstack ownership) and the team could in the terminology used in team topologies be characterised as a complicated subsystems team. However, the team was also itself using the core domain to implement a product and was thus also acting as a stream aligned team.
The team had built a BFF to enable the front-end of their product. The BFF exposed an API, used by the mobile app, that would authenticate the user and then delegate to the underlying backend service. It was also responsible for how the product was shown in the UI and for sending out notifications to users and this was implemented in an event driven way, by consuming event messages published by the backend service and then reactively refreshing the UI or pushing notifications.

The first few products built by other teams had no special requirements with regards to the UI and notifications, and it was therefore decided that they could be relying on this BFF to handle that part of the functionality for them. Later products had slightly different requirements. E.g. one product needed to show a different text in the notifications and that functionality was therefore implemented in the service belonging to that product and a corresponding `if` statement was added to the BFF to exclude the notifications for that specific service. The product also had one difference in the functionality in the UI, the item shown in the UI could not be deleted for this product which was possible in the common functionality, thus another `if` statement was added here. Another product did not exist in the app at all, it was provided to a different user base that did not use the app. Again, appropriate `if` statements were added in the BFF to exclude the handling of the UI and notifications for this product.

Do you see where this is going? The BFF service broke the single responsibility principle, it implemented common functionality for products that were not related. Every time new products were added, or existing products were altered, one needed to consider whether that product feature set would fit into the BFF's common functionality and if not make special cases to exclude certain parts. Likewise when making changes to the functionality within the BFF service a developer would need to consider the entire set of products that was using the BFF service to ensure that the changes made did not break any existing functionality in any of those products. This was a near impossible task as every product was different and the product catalog spanned many domains. To make matters worse, the list of products using the BFF was not readily visible in the code but could only be obtained by asking developers that had the historical context or looking at call graphs or logs. The initial intention of being more efficient by reusing existing functionality so that product teams did not have to write code that already existed eventually led to a brittle and hard to maintain system.

Investigating the domain should have made it apparent that current and future products were not identical. Also, since the products were user facing, as time goes by it is only natural that requirements for each product diverges because product owners will want to iterate on their products making them more sophisticated. If this had been realised from the beginning developers could have chosen to either not reuse any functionality at all or, if feasible, put reusable parts of the code into a library that the other product teams could use to implement their product features.

{% endnote %}

### Anti-pattern 2: Ghost domain

As the business evolves and is expanded with new capabilities/processes new domains can emerge. If the new domain is not identified in time, implementation of the related capabilities/process could get scattered all over the organisation and ending up in multiple bounded contexts leading to [Shared responsibility](#shared-responsibility).

{% note 'Real world example' %}

A company would charge fees for the different products/services they provided to their customers. There were many products/services and they were implemented by the various microservices in their microservice architecture and initially each microservice would directly charge a fee if they had carried out an action that required it. After some time it became apparent that there were many business rules and processes related to the management of fees. Some types of fees should only be charged if the user was in a certain membership tier, there were rules about discounts, e.g. if many fees had been charged in a short period. The company was also required by law to send out yearly fee statements to their customers so they could see which fees had been charged. Implementing these business processes quickly became a nightmare due to the scattered implementation of the fees. While some of the requirements related to the fee domain might not have been known initially, the requirement dictated by law should have been anticipated and would naturally have let to the discovery of the fee domain early in the development process.

The solution was to specify different types of fees and have each microservice notify the fee service about fees that needed to be charged but let the fee service take responsibility for handling the fees. This kept the decision on which specific action required fees to be charged within the service that implemented them, ensuring a low coupling of the fee service to the other services while keeping the responsibility of handling the fees and all related business processes within the fee service.

{% endnote %}

### Anti-pattern 3: Entanglement

**The representation of the problem space in the code is entangled with technical concepts from the solution space.**

This means that when the solution changes for purely technical reasons, e.g. because of a non functional requirement, code containing business logic will likely need to be refactored. This is wasteful and, as always, comes with the risk of introducing bugs. If the solution specific concepts has bled into the APIs or events this could also effect dependent services.

Business logic from the domain model leaks into technical components or technical components leak into the domain model. This violation of separation of concerns means that when you need to change your code for technical reasons (i.e. not to change business logic), e.g. fixing a bug, upgrading a library/framework to a newer version or simply refactoring the code you risk making unintended changes to the business logic. Likewise, understanding the business logic that comprises the domain model becomes harder because the code is entangled with code that is only there for technical reasons and does not exist in the problem space.

{% note 'Real world example' %}

A team was responsible for modelling a `SalesOrder` entity. As part of managing the SalesOrder process the team was also doing a lot of orchestration, calling other services and updating the state of the SalesOrder entity accordingly. In this particular case the orchestration process was purely there to implement a distributed transaction and did not represent a business workflow and as such only lived in the solution space. However, they had not separated the orchestration process from the modelling of the SalesOrder entity and this resulted in details related to the orchestration process to leak into the domain model. The domain model was responsible for storing information such as "async request to service X has been initiated, waiting for a response". Whenever a change to the orchestration process was needed, e.g. a service that was depended upon was replaced with another, this meant touching code that was located in the same place as the domain model, and therefore also risking making unintended changes. Sometimes the orchestration process (saga) would get into a bad state because something unexpected happened and it was needed to get it back on track. This was done by introducing new steps in the process that were only there because of the specific incident that caused the saga to end up in the bad state. Over time this polluted the saga code, and therefore also the domain model code with logic that made very little sense without the context of the historic incident, leading to a bloated domain model that was hard to understand and maintain. The sagas in this example were breaking the single responsibility principle. They were responsible for implementing the business process AND for implementing the orchestration.

{% endnote %}

As an example of entanglement consider a service that publishes an event with information needed for a salesforce integration, perhaps the event contains a salesforce related ID. The event is being used as a domain event also. When the partnership with salesforce ends it will not be possible to stop publishing the event because it is used elsewhere.

Another example of this could be a single concept (e.g. a product catalog) being spread out over multiple event definitions, because they happen to be published by two different microservices in the solution space. This will make it very hard to consume the data. How do I know that I have consumed all the data related to product catalogs? How do I know whether this business rule that I must implement is taking all instances of an enitity into consideration if events pertaining to that entity are being published in many places in the backend, and how do I know that yet another event will not be created in the future thus breaking the correctness of the implementation because it will be ignorant of this new event? It will also be brittle, because when someone wants to refactor the backend for technical reasons (not because of changes to the problem space), e.g. merging two microservices into one, the event definitions might change causing dependent teams extra work to change how they consume the data. This would not have happened if they were proper domain events because proper domain events will only need to change when there are changes in the problem space.

### Anti-pattern 4: Misaligned abstraction

**A bounded context has implemented an abstraction which does not exist in the problem space. Changes to requirements breaks the abstraction forcing the owning team and all dependent teams to refactor.**

An important aspect of modelling is abstractions. Developers come up with abstractions that will represent some concept or reusable functionality. What happens if the abstractions are not grounded in the problem space? Remember, the requirements are born in the problem space and they will tickle down and hit the abstraction, but if the abstraction is not something that exists in the problem space there is no guarantee that these requirements will align with it. The addition of a new requirement might not fit within the abstraction, forcing the developer to rethink the abstraction or create another. It is therefore a good idea to think about your abstractions from the perspective of the problem space. Did you come up with the abstraction yourself while coding or do the business stakeholders know what this is when you mention its name? Is it something that exist in some shape or form in the problem space, either concretely as a physical object or something less tangible like a concept people from the problem space are using in conversations. As always, a stint of pragmatism is good, your abstractions need not all be grounded in the problem space, but it is always a good idea to be conscious about these things and accepting the risks that comes with your misaligned abstractions.

### Anti-pattern 5: Dominant partner

A system integrates with a vendor or partner that provides capabilities to the company that spans multiple of the company's domains and this violation of single responsibility bleeds into the architecture of the system. In this scenario a single team is given the responsibility of integrating with the vendor/partner and that single team implements all the business processes that are related to those capabilities. That team now has responsibilities that are belonging to all those domains. Depending on the size of those domains this can end up being too much responsibility for a single team to handle. As the company evolves and expands into new teams that will take over some of those domains, the responsibility of the existing code will need to be handed over, otherwise the initial team will now have a slice of the responsibility of all those domains, leading to a shared responsibility with the other teams. If the initial team had segregated the code belonging to the different domains into separate microservices handing over the code is a matter of handing over the responsibility of those service to the respective squads. However if the initial team had coupled together the code from the various domains, untangling it and handing it over can be a sizeable task, most likely something that will be postponed. This leads to [Violation of the single responsibility principle](#violation-of-the-single-responsibility-principle), [Shared responsibility](#shared-responsibility) and [Inconsistent responsibility boundaries](#inconsistent-responsibility-boundaries).

This situation often occur because developers are not even aware that multiple domains are involved. It can also occur because the ramifications of ending up in this situation is greatly underestimated.

It is very similar to the well known Blob (or God object) antipattern. The team and their code is ubiquitous. The team members are required in most meetings and your architect will go around the office and utter sentences such as "this team is the beating heart of the company", and will likely not realise that this is a very bad thing. Worse still, those team members will become highly esteemed and have a high degree of influence, a situation that can be desirable for an engineer and there is a risk that those engineers will not be motivated to push for changes.

### Anti-pattern 6: Leaking complexity

While having a good understanding of your own domain is paramount it is not sufficient. In order to build good APIs and good integrations with other bounded contexts it is necessary to have some understanding of the business processes that are depending on your domain. Having this understanding enables you to design APIs that are fit for purpose. Not having this understanding usually leads to teams building APIs that reflect their domain model directly. If the domain is a complex one this will force dependent teams to understand and interact with the domain model in its full complexity even if their use case is a simple one. E.g. in an event driven architecture external events would reflect internal domain events directly and in a complex domain there would be many events and many details and relations to understand and writing and maintaining the code that consumes the data can be a big task.

## Project management

In organisations characterised by short term focus and where activities concerned with gaining an understanding of the problem space are not valued or prioritised project management will often take decisions that will make the situation worse. In this section I've listed a few examples.

### Accumulating tech debt

As the business expands some teams will no longer be able to deal with the cognitive load and responsibility boundaries will need to be altered. Sometimes this is done by placing new feature development with a different team and leaving the old team with the maintenance of the old solution. Often there is no agreed plan on when and how to migrate the old responsibilities to the new team and this results in a fragmented solution space that suffers from e.g. [Inconsistent responsibility boundaries](#inconsistent-responsibility-boundaries). Quite often the reason for not prioritizing the alignment is that the consequences of not doing so are underestimated.

{% note 'Real world example' %}

A company entered a new country and needed to generalise the existing features to work in the new country but also build new country specific features. The  responsibilities for the existing solution were split between a stream-aligned team and a `complicated subsystems` team. When development started on adding support for the new country it was decided that it would be better for the complicated subsystems team to be a stream-aligned team, and a new solution based on this decision was built for the new country. Years passed, and the misalignment of the architectures for the different countries persisted. In the new country the team acted as a stream-aligned team and in the old country that role was still assigned to the old team. This caused confusion for the developers and all stakeholders. E.g. Triaging incoming service desk tickets was a big challenge because it was quite difficult for non-technical staff to determine ownership of specific tickets.

{% endnote %}

### Responsibility is delegated based on roadmap bandwidth

In an organisation that has no clear idea of the domain landscape in their problem space and where this is not taken into consideration from project management and leadership responsibility of new projects are often delegated based on team availability. This is the most obvious way to delegate tasks as it optimises utilisation of manpower, but there is obviously no correlation between roadmap bandwidth and domain ownership, so this naturally leads to a scattered ownership landscape, e.g. [Inconsistent responsibility boundaries](#inconsistent-responsibility-boundaries). There is nothing inherently wrong in taking roadmap bandwidth into consideration but if there is no anchoring in domain ownership to help steer the decisions it quickly leads to entropy.

{% note 'Real world example' %}

A team was responsible for a domain but only for the users located in some of the countries. For users from other countries the responsibility for the domain lied within a different team, even though the problem space (in this example) did not distinguish between users from different countries. This situation can e.g. occur when different countries requires different integrations and the implementation of those integrations are carried out over time correlated to when the company enters those countries. In those situations there is a possibility that the team that owns the domain does not have room in their roadmap when the time comes and the implementation task is then handed over to another team. This leads to the domain responsibility being scattered. Since, in this example, the country boundary does not exist in the domain, product evolution will happen across this boundary going forward, i.e. new features will/should be introduced and changed for all countries at the same time, however since the responsibility for all countries are not owned by a single team, implementing the new functionality would involve multiple teams leading to project and roadmap coordination work and possibly duplicated effort for the implementation.

{% endnote %}

### Responsibility is delegated based on technology familiarity

When the implementation of a new business capability involves a specific technology already known by a subset of teams one of those teams will be selected for carrying out the implementation while completely disregarding if the new business capability belongs to a domain that the team is already responsible for. This leads to [Shared responsibility](#shared-responsibility) or  [Inconsistent responsibility boundaries](#inconsistent-responsibility-boundaries). Responsibilities of new capabilities that belong to domains owned by other teams wÃ­ll get assigned to the team that has the experience with the technology and the team is effectively taking slices of the responsibilities that should belong to the other teams.

It is not necessary for technology based knowledge to be tied to specific teams. The experienced team can act as mentors and share knowledge with other teams, or they can build generic (i.e. not domain specific) components, like libraries or services, that can be used by other teams that need to use the technology.

### Responsibility is delegated based on solution space

A component of the system is taking on too much responsibility and is often involved when new features are developed. For this reason the team owning the component will often be delegated responsibility of business processes/capabilities that belong to domains owned by other teams. This is a variant of the dominant partner antipattern, in this case though, the system that crosses responsibility boundaries is built in-house but the effects are the same. This situation often occur because developers are not even aware that multiple domains are involved. It can also occur because the ramifications of ending up in this situation is greatly underestimated.

This is often seen when complex subsystem teams or platform teams builds generic components that gets entangled with the business domains. E.g. it could be a team owning a CRM product or a customer service product. If care is not taken to allow other teams to plug in to the generic component often the team owning the generic component ends up becoming a bottleneck and ends up taking slices of the domains of other teams, leading to [Shared responsibility](#shared-responsibility) or  [Inconsistent responsibility boundaries](#inconsistent-responsibility-boundaries).

## Why is this so hard

This is all really quite obvious, isn't it? You need to understand the problem you're solving. So why is it so hard to get right?

### DRY

Let's talk a bit about the DRY principle, don't repeat yourself. If code is duplicated, maintenance becomes difficult. When making changes you need to remember to update the code in all the places it's duplicated and there's a chance you'll miss some of it, leading to inconsistent code and bugs! Therefore we should move the duplicated code into a function or a class and then reference that. As a developer this is one of the first principles you learn. It is easy to grasp and makes so much sense! This is really what programming is all about, creating reusable functions and classes that can be composed into larger structures. Even your IDE reminds you about this, if you have duplicated code it will tell you. The duplicated code is staring you right in the face! Just remember one thing, the DRY principle is defined within the confines of your solution space. What if that seemingly duplicated code is actually representing two different concepts in the problem space that, for the time being, just happens to have the same definition in the solution space? Think about the product catalog and the checkout domains from the Amazon example. They both have a product entity and they have the same definition but when Aaron asks you to add a "related products" property to the product catalog and Bridget does not, they are no longer the same. If you understand the problem space you also understand that the product catalog and the checkout process are two very different concepts and you will realise that when you look at your code. You'll know that they'll likely diverge in the future and will resist the temptation to apply the DRY principle and merge together the two identical product classes into one. In this example it is very obvious that there are two representations of a product, but your particular problem space might be much more complex or a lot less intuitive than this toy example. If you don't understand the problem space and is not constantly aware of its presence you'll likely miss this and make the obvious choice and apply the DRY principle instead.

The DRY principle only makes sense to adhere to if the duplicated code is duplicating concepts from your problem space. Let's say you had implemented a business capability in a service and you needed to support another capability that had the same functionality up to that point but where the remaining work would diverge, then there is nothing fundamentally wrong about copying a service consisting of 1000s of lines of code and handing it over to another team to allow them to build that new capability while allowing you to evolve the existing. This doesn't happen often in practice, but consider it. It goes against your gut to copy 1000s of lines of code, but your gut feeling could be wrong.

Sometimes pragmatism wins and reusing a service even if it is not fit for purpose is still the right choice. Time to market, resource allocation constraints etc. should of course always be factored in. However, there is a big difference between making this choice with open eyes, knowing that this could cause problems later as the solution evolves and taking necessary precautions, and on the other hand not realising that there even is an issue and end up in a bad situation later when the solution is not fit for the new requirements.

### Deceptiveness

You can spend your entire professional life confined within the solution space, adapting the solution iteratively as you learn more about the requirements during development. You can skip the event storming, the ubiquitous language and all of the other DDD practices. It will work and you'll be able to deliver the requested feature. Some new requirements will require a larger overhaul of the design because they cannot easily be adapted, the project will last several months/year but you'll eventually deliver the new features, while also having improved and cleaned up the solution, and everyone is happy. Little do the developers and stakeholders know that if only the solution had been a better fit to the problem space to begin with the larger refactoring project would not have been needed and the features could have been delivered in a few weeks. This is an alternative reality that never existed. Stakeholders usually don't have a good idea about what would be a reasonable amount of time to implement a feature. Sure it looks easy on paper, but IT is complex!

The misalignment between the problem space and solution space is not apparent when a developer is looking at the code. Even if the code looks SOLID it might very well be that the apparent single responsibility of a class in the code is actually multiple responsibilities in the problem space. Later when a change arrives in the problem space it can be hard to implement because the class implementing the related functionality is used to solve a different independent requirement in the problem space.

As mentioned, when your code base does not have the high cohesion/low coupling characteristics maintainability and evolution of the solution will be harder. However, in a distributed system the evolution of the solution might happen in another team that will then suffer the consequences of the bad choices made by your team. This is very common. This means that you will not yourself suffer the consequences of your bad choices. This can mean that teams do not learn from their mistakes. The price is paid in slower development and a less robust solution throughout the organisation, but it is not at all easy to see the cause and effect from a local perspective. Therefore architects with more of an overview are needed for sparring.

People think they can take an iterative just-in-time approach with regards to requirement gathering (i.e domain understanding). They have an agile mindset and they think they can POC it, put it in production, gather feedback and then continuously re-iterate. There is nothing wrong with being agile but they don't realise the huge costs associated with rewriting the software. This is especially true for microservice architectures. If the refactoring goes beyond the boundaries of bounded contexts this means changing APIs and coordinating the new release with all involved teams. Perhaps even migrating existing state between services. If the architecture is event oriented it might also involve recreating the new events for historic data and reconstituting to all consumers.

It is very difficult to detect the misalignment in realtime because quite often the consequences of the misinformed decisions do not appear until later when the solution must be evolved and it is no longer a good fit. By the time that the symptoms, such as a tightly coupled architecture, unclear responsibility boundaries, the constant need for refactoring projects and the build up of legacy code becomes visible, it is far too late.

### The business is not run by tech

There is often a big pressure from management to focus efforts on feature development and it can be a challenge to communicate the value of working on other tasks because they are often very technical in nature. This is a well known problem when dealing with e.g tech debt and it is also problem here.

## How to fix this issue?

As a first measure you should try to assess your situation. If you're not currently following DDD or similar practices chances are that your solution is misaligned with the problem space. Take notice of people from the organisation speaking of areas of responsibilities that you were not aware of. "I really want X (person or group of people) to take responsibility for Y". If this does not align with your reality then this is an indication that their view of the world is different than yours, that is, your understanding of the problem space conflicts with theirs. In this case your solution might be fitted well to your understanding of the problem space, but that understanding could be wrong or just not aligned with the rest of the organisation.

Everytime you need to do a bug fix or refactoring task, think about how you ended up in this situation. Did it happen due to not putting enough consideration/effort into the original solution, e.g. because of time constraints, or was the original solution actually thorough, but the issue arose because of incomplete understanding of the problem that was being solved? If the latter case occurs often it is time to put more focus on practices aimed at improving your understanding of the problem space in due time (i.e. not just-in-time)

Secondly, the business or management might need some convincing before they will allow you to invest resources into improving your understanding of the problem space. The responsibility for doing this usually belongs to a head-of-tech or a CTO if such a role exists in your company. Try to give examples of projects from the past that were harder and took longer than they should have. Projects that were simple in the problem space but became very complex in the solution space. Perhaps you can find examples of projects that involved many teams and required coordination and project management and were difficult to roll out and test due to all the interdependencies even though the problem belonged to a single domain? Being able to deliver projects faster and give more reliable estimates constitute convincing arguments. You could also try to highlight the amount of legacy code that has been generated.

Finally you might need to make adjustments to the organisation. Every domain should have a designated product owner who has the responsibility of keeping the understanding of the problem space up to date. That involves understanding how the business currently operates and how it is expected to evolve in the near or mid term future. The company should have designated architects. The architects will be in close contact with the stakeholders and product owners and keep an up to date model of the current and future domain landscape. They will understand the current architecture of the solution and be responsible for a target architecture that should strive to align the solution as much as possible with the domain landscape.

## Final thoughts

Software design is an inherent iterative process. Most of the industry have now moved on from the days of the waterfall process and learned that splitting the process into a design and an implementation phase is almost never feasible. The devil is in the details and even small development tasks can't be designed up front because often new details and unforeseen obstacles appear while coding. However, the fact that development is carried out in an agile fashion should not lead one to believe that gathering requirements and understanding the problem space can wait till the very last moment. The misalignment between the problem space and the solution space that this approach allows to exist will negatively impact maintainability and thus profitability in the long run.

You can build your design and abstractions based on your intuitions and, depending on how well you know the domain, they'll probably fit well enough, at least for some time, but if the product lives long enough, sooner or later it will catch up to you and the design overhaul will become a reality. This happens all the time. How many of the projects that you worked on were brownfield or greenfield projects? They're mostly greenfield on paper, but many of them are just a new generation of the old solution that no longer was able to fit the problem space. (there are of course other reasons why projects needs to be rebuilt, like deprecated tech stacks, mergers etc.) Again, this is not a big tragedy, but it certainly is very wasteful and not at all cost efficient in the long run. Thing is, budgets are often short lived and time to market is vital. This is often the reality and those factors should of course be weighed in when considering if and how DDD could be relevant. Just remember that projects tend to stay around much longer than the initial budget and if you intend to stay around as well you'll do your future self a huge disservice if you don't think ahead.
